<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>S1 Kötzschenbroda ➜ Freiberger Str. (VVO)</title>
  <style>
    body { font-family: sans-serif; background: #f8f8f8; margin: 0; padding: 0.8em;}
    .kopf { font-size:1.15em; margin-bottom:0.8em; }
    .fahrt { border-bottom:1px solid #ddd; padding:0.5em 0; }
    .zeit { font-weight:bold; min-width:52px; display:inline-block;}
    .verz { color:#b00; font-weight:bold; }
    .zugnr { font-size:0.9em; color:#888; }
    .ziel { color: #05398F; font-weight: bold;}
  </style>
</head>
<body>
  <div class="kopf">Nächste S1: Kötzschenbroda ➜ Freiberger Str.</div>
  <div id="output">Lade...</div>
  <script>
    // StopIDs laut VVO-API: Kötzschenbroda = 33000051, Freiberger Str. = 33000151
    function ladeVerbindungen() {
      fetch("https://webapi.vvo-online.de/tr", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          from: { id: "33000051" },        // Start: Kötzschenbroda
          to:   { id: "33000151" },        // Ziel: Freiberger Str.
          limit: 4,                        // Hole mehr, damit wir explizit S1 rausfiltern
          // Optional kannst du eine Abfahrtzeit explizit setzen: 'when': '2024-08-01T14:55:00'
        })
      })
      .then(r => r.json())
      .then(data => {
        // Extrahiere nur Fahrten mit direkter S1 – Rest kann man nach Wunsch rausfiltern
        const trips = (data.Trips || [])
          .filter(trip =>
            trip.Legs.length === 1 &&                          // Nur Direktfahrten (kein Umstieg)
            trip.Legs[0].Line && trip.Legs[0].Line.Name === "S1"
          ).slice(0,2);

        document.getElementById("output").innerHTML = trips.length > 0
          ? trips.map(trip => {
              const leg = trip.Legs[0];
              // Zeitformatierung
              const abEpoch = parseInt(leg.Departure.Time.match(/\d+/)[0]);
              const anEpoch = parseInt(leg.Arrival.Time.match(/\d+/)[0]);
              const ab = new Date(abEpoch);
              const an = new Date(anEpoch);

              // Verspätung?
              let delay = "";
              if (leg.Departure.State === "Delayed") {
                const planEpoch = parseInt(leg.Departure.ScheduledTime.match(/\d+/)[0]);
                const diffMin = Math.round((abEpoch - planEpoch) / 60000);
                if (diffMin > 0) delay = ` <span class="verz">+${diffMin} min</span>`;
              }
              return `<div class="fahrt">
                <span class="zeit">${ab.toLocaleTimeString([], {hour:"2-digit", minute:"2-digit"})}</span>
                <span class="ziel">S1 ➔ Freiberger Str.</span>
                <span style="color:#888;">(an ${an.toLocaleTimeString([], {hour:"2-digit",minute:"2-digit"})})</span>
                ${delay}
                <span class="zugnr">[${leg.Line.TrainNum || ""}]</span>
              </div>`;
            }).join("")
          : "<div>Keine passende Direktverbindung in nächster Zeit gefunden.</div>";
      })
      .catch(() => {
        document.getElementById("output").innerText = "Fehler bei der VVO-Verbindungsabfrage!";
      });
    }
    ladeVerbindungen();
    setInterval(ladeVerbindungen, 60000); // alle 60s neu laden
  </script>
</body>
</html>
